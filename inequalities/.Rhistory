install.packages(c("abind", "ade4", "AER", "alabama", "alpaca", "askpass", "backports", "basefun", "bayesplot", "bdsmatrix", "bit", "bit64", "bitops", "blob", "blogdown", "bookdown", "brew", "brio", "broom", "bslib", "cachem", "Cairo", "callr", "car", "caret", "caTools", "checkmate", "classInt", "cli", "clipr", "clue", "cluster", "clusterSim", "coda", "coin", "collapse", "colorspace", "colourpicker", "commonmark", "conquer", "corrplot", "covr", "cowplot", "coxme", "cpp11", "crayon", "credentials", "crosstalk", "cubature", "Cubist", "curl", "data.table", "DBI", "dbplyr", "dendextend", "DEoptimR", "desc", "devtools", "DiagrammeR", "digest", "distill", "distributional", "downlit", "dplyr", "dreamerr", "DT", "dtplyr", "dtw", "dtwclust", "e1071", "earth", "effects", "ellipse", "EnvStats", "estimability", "evaluate", "FactoInvestigate", "FactoMineR", "Factoshiny", "fansi", "farver", "fastICA", "fastmap", "fitdistrplus", "fixest", "flexclust", "FNN", "fontawesome", "forcats", "foreign", "formatR", "Formula", "fs", "future", "future.apply", "gam", "gargle", "gbm", "geepack", "generics", "gert", "GGally", "ggplot2", "ggpubr", "ggrepel", "ggsci", "ggsignif", "gh", "gitcreds", "glmnet", "globals", "glue", "googledrive", "googlesheets4", "gower", "gplots", "gtable", "gtools", "hardhat", "haven", "highr", "Hmisc", "hms", "htmlTable", "htmltools", "htmlwidgets", "httpuv", "httr", "igraph", "influenceR", "insight", "ipred", "ipumsr", "isoband", "iterators", "jsonlite", "kernlab", "klaR", "knitr", "knitrBootstrap", "ks", "labeling", "labelled", "later", "lava", "leaflet", "leaflet.providers", "leaps", "lfe", "libcoin", "listenv", "lme4", "lmtest", "locfit", "logspline", "lubridate", "magick", "magrittr", "maps", "markdown", "MatchIt", "MatrixModels", "matrixStats", "maxLik", "mclust", "mda", "metathis", "mice", "microbenchmark", "minqa", "miscTools", "missMDA", "mlbench", "MLmetrics", "mlt", "mockery", "modelr", "mosaic", "multcomp", "multicool", "munsell", "mvtnorm", "nloptr", "nnet", "nor1mix", "openssl", "openxlsx", "orthopolynom", "packrat", "pamr", "parallelly", "party", "patchwork", "pcaPP", "pillar", "pixmap", "pkgbuild", "pkgdown", "pkgload", "plm", "plotmo", "plotrix", "pls", "plyr", "png", "polynom", "posterior", "prettyunits", "pROC", "processx", "prodlim", "progress", "progressr", "promises", "proxy", "ps", "pscl", "purrr", "quantreg", "qvcalc", "R.cache", "R.devices", "R.methodsS3", "R.oo", "R.rsp", "R.utils", "r2d3", "R2HTML", "ragg", "randomForest", "RANN", "raster", "rbibutils", "RColorBrewer", "Rcpp", "RcppArmadillo", "RcppEigen", "RcppParallel", "RcppThread", "Rdpack", "readr", "readstata13", "readxl", "recipes", "rematch", "remotes", "reprex", "reshape", "rgl", "rio", "rJava", "RJSONIO", "rlang", "rmarkdown", "robustbase", "roxygen2", "rpart", "rprojroot", "rrcov", "rsconnect", "RSpectra", "rstatix", "rstudioapi", "RUnit", "rversions", "rvest", "s2", "sandwich", "sass", "scatterplot3d", "servr", "shape", "shiny", "som", "sourcetools", "sp", "SparseM", "stringi", "stringr", "strucchange", "styler", "survey", "sys", "systemfonts", "TeachingDemos", "testthat", "textshaping", "TH.data", "themis", "tibble", "tidyr", "tidyselect", "tidyverse", "timeDate", "tinytest", "tinytex", "tram", "tzdb", "units", "usethis", "utf8", "uuid", "vdiffr", "vip", "viridis", "viridisLite", "visNetwork", "vroom", "waldo", "whisker", "withr", "wk", "writexl", "xfun", "xml2", "xopen", "yaml", "zip", "zoo"))
#######################################################################################
#
#                             - Measuring Mobility -
#
# by Frank A. Cowell and E. Flachaire, October 2017
#
# replication file: Table 7, Mobility in China
#
#######################################################################################
rm(list=ls(all=TRUE))
setwd("C:/Users/Arnaud/Documents/GitHub/research_code/inequalities")
# Define a function to compute the Cowell-Flachaire summary index
CFp = function(p, a=0) {
K=NROW(p)
Ma=0
if(a==0)
for(k in 1:K)
for (l in 1:K)  Ma = Ma + p[k,l]*l*log(k/l) * (-2/(K*K+K))
else if(a==1)
for(k in 1:K)
for (l in 1:K)  Ma = Ma + p[k,l]*k*log(k/l) * (2/(K*K+K))
else {
for(k in 1:K)
for (l in 1:K)  Ma = Ma + p[k,l]*k^a*l^(1-a)
Ma= (1/(a*a-a)) * ((2/(K*K+K))*Ma - 1 )
}
return(Ma)
}
# Read the data
data1 <- read.table("panelHHincome1.txt",header=TRUE)
r1=rank(data1$inc1)/NROW(data1$inc1)
r2=rank(data1$inc2)/NROW(data1$inc2)
# Compute the transition matrix
rg1 = (r1<=.2) + 2*(r1>.2 & r1<=.4) + 3*(r1>.4 & r1<=.6) + 4*(r1>.6 & r1<=.8) + 5*(r1>.8)
rg2 = (r2<=.2) + 2*(r2>.2 & r2<=.4) + 3*(r2>.4 & r2<=.6) + 4*(r2>.6 & r2<=.8) + 5*(r2>.8)
trf <- table(data.frame(R0=rg1,R1=rg2))
TMat = trf/rowSums(trf)
# Compute the bootstrap (percentile) confidence interval
nboot=999
Mb=numeric(nboot)
set.seed(100)
a1=rep(1:5, each=NROW(rg1)/5)
a2=numeric(NROW(a1))
for(b in 1:nboot) {
# generate a sample of size n from the transition matrix
for(i in 1:NROW(a1)) a2[i] = sample(5,size=1,prob=TMat[a1[i],])
# compute the transition matrix
trfb <- table(data.frame(R0=a1,R1=a2))
TMatb = trfb/rowSums(trfb)
# compute the summary index
Mb[b]=CFp(TMatb,a=0)
}
res=c(CFp(TMat,a=0),quantile(Mb,.025),quantile(Mb,.975))
# Show the results
round(TMat,3)   # Show the transition matrix
round(res,3)    # Show the summary index and its confidence interval at 95%
#######################################################################################
#
#                             - Measuring Mobility -
#
# by Frank A. Cowell and E. Flachaire, October 2017
#
# replication file: Table 7, Mobility in China
#
#######################################################################################
rm(list=ls(all=TRUE))
setwd("C:/Users/Arnaud/Documents/GitHub/research_code/inequalities")
# Define a function to compute the Cowell-Flachaire summary index
CFp = function(p, a=0) {
K=NROW(p)
Ma=0
if(a==0)
for(k in 1:K)
for (l in 1:K)  Ma = Ma + p[k,l]*l*log(k/l) * (-2/(K*K+K))
else if(a==1)
for(k in 1:K)
for (l in 1:K)  Ma = Ma + p[k,l]*k*log(k/l) * (2/(K*K+K))
else {
for(k in 1:K)
for (l in 1:K)  Ma = Ma + p[k,l]*k^a*l^(1-a)
Ma= (1/(a*a-a)) * ((2/(K*K+K))*Ma - 1 )
}
return(Ma)
}
# Read the data
data1 <- read.table("panelHHincome2.txt",header=TRUE)
r1=rank(data1$inc1)/NROW(data1$inc1)
r2=rank(data1$inc2)/NROW(data1$inc2)
# Compute the transition matrix
rg1 = (r1<=.2) + 2*(r1>.2 & r1<=.4) + 3*(r1>.4 & r1<=.6) + 4*(r1>.6 & r1<=.8) + 5*(r1>.8)
rg2 = (r2<=.2) + 2*(r2>.2 & r2<=.4) + 3*(r2>.4 & r2<=.6) + 4*(r2>.6 & r2<=.8) + 5*(r2>.8)
trf <- table(data.frame(R0=rg1,R1=rg2))
TMat = trf/rowSums(trf)
# Compute the bootstrap (percentile) confidence interval
nboot=999
Mb=numeric(nboot)
set.seed(100)
a1=rep(1:5, each=NROW(rg1)/5)
a2=numeric(NROW(a1))
for(b in 1:nboot) {
# generate a sample of size n from the transition matrix
for(i in 1:NROW(a1)) a2[i] = sample(5,size=1,prob=TMat[a1[i],])
# compute the transition matrix
trfb <- table(data.frame(R0=a1,R1=a2))
TMatb = trfb/rowSums(trfb)
# compute the summary index
Mb[b]=CFp(TMatb,a=0)
}
res=c(CFp(TMat,a=0),quantile(Mb,.025),quantile(Mb,.975))
# Show the results
round(TMat,3)   # Show the transition matrix
round(res,3)    # Show the summary index and its confidence interval at 95%
