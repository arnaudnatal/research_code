#######################################################################################
#
#                             - Measuring Mobility -
#
# by Frank A. Cowell and E. Flachaire, October 2017
#
# replication file: Table 7, Mobility in China
#
#######################################################################################
rm(list=ls(all=TRUE))
setwd("C:/Users/Arnaud/Documents/GitHub/research_code/assetsinequalities")
# Define a function to compute the Cowell-Flachaire summary index
CFp = function(p, a=0) {
K=NROW(p)
Ma=0
if(a==0)
for(k in 1:K)
for (l in 1:K)  Ma = Ma + p[k,l]*l*log(k/l) * (-2/(K*K+K))
else if(a==1)
for(k in 1:K)
for (l in 1:K)  Ma = Ma + p[k,l]*k*log(k/l) * (2/(K*K+K))
else {
for(k in 1:K)
for (l in 1:K)  Ma = Ma + p[k,l]*k^a*l^(1-a)
Ma= (1/(a*a-a)) * ((2/(K*K+K))*Ma - 1 )
}
return(Ma)
}
# Read the data
data1 <- read.table("panelHHassets1.txt",header=TRUE)
r1=rank(data1$inc1)/NROW(data1$ass1)
r2=rank(data1$inc2)/NROW(data1$ass2)
# Compute the transition matrix
rg1 = (r1<=.2) + 2*(r1>.2 & r1<=.4) + 3*(r1>.4 & r1<=.6) + 4*(r1>.6 & r1<=.8) + 5*(r1>.8)
rg2 = (r2<=.2) + 2*(r2>.2 & r2<=.4) + 3*(r2>.4 & r2<=.6) + 4*(r2>.6 & r2<=.8) + 5*(r2>.8)
trf <- table(data.frame(R0=rg1,R1=rg2))
TMat = trf/rowSums(trf)
# Compute the bootstrap (percentile) confidence interval
nboot=999
Mb=numeric(nboot)
set.seed(100)
a1=rep(1:5, each=NROW(rg1)/5)
a2=numeric(NROW(a1))
for(b in 1:nboot) {
# generate a sample of size n from the transition matrix
for(i in 1:NROW(a1)) a2[i] = sample(5,size=1,prob=TMat[a1[i],])
# compute the transition matrix
trfb <- table(data.frame(R0=a1,R1=a2))
TMatb = trfb/rowSums(trfb)
# compute the summary index
Mb[b]=CFp(TMatb,a=0)
}
#######################################################################################
#
#                             - Measuring Mobility -
#
# by Frank A. Cowell and E. Flachaire, October 2017
#
# replication file: Table 7, Mobility in China
#
#######################################################################################
rm(list=ls(all=TRUE))
setwd("C:/Users/Arnaud/Documents/GitHub/research_code/assetsinequalities")
# Define a function to compute the Cowell-Flachaire summary index
CFp = function(p, a=0) {
K=NROW(p)
Ma=0
if(a==0)
for(k in 1:K)
for (l in 1:K)  Ma = Ma + p[k,l]*l*log(k/l) * (-2/(K*K+K))
else if(a==1)
for(k in 1:K)
for (l in 1:K)  Ma = Ma + p[k,l]*k*log(k/l) * (2/(K*K+K))
else {
for(k in 1:K)
for (l in 1:K)  Ma = Ma + p[k,l]*k^a*l^(1-a)
Ma= (1/(a*a-a)) * ((2/(K*K+K))*Ma - 1 )
}
return(Ma)
}
# Read the data
data1 <- read.table("panelHHassets1.txt",header=TRUE)
r1=rank(data1$ass1)/NROW(data1$ass1)
r2=rank(data1$ass2)/NROW(data1$ass2)
# Compute the transition matrix
rg1 = (r1<=.2) + 2*(r1>.2 & r1<=.4) + 3*(r1>.4 & r1<=.6) + 4*(r1>.6 & r1<=.8) + 5*(r1>.8)
rg2 = (r2<=.2) + 2*(r2>.2 & r2<=.4) + 3*(r2>.4 & r2<=.6) + 4*(r2>.6 & r2<=.8) + 5*(r2>.8)
trf <- table(data.frame(R0=rg1,R1=rg2))
TMat = trf/rowSums(trf)
# Compute the bootstrap (percentile) confidence interval
nboot=999
Mb=numeric(nboot)
set.seed(100)
a1=rep(1:5, each=NROW(rg1)/5)
a2=numeric(NROW(a1))
for(b in 1:nboot) {
# generate a sample of size n from the transition matrix
for(i in 1:NROW(a1)) a2[i] = sample(5,size=1,prob=TMat[a1[i],])
# compute the transition matrix
trfb <- table(data.frame(R0=a1,R1=a2))
TMatb = trfb/rowSums(trfb)
# compute the summary index
Mb[b]=CFp(TMatb,a=0)
}
res=c(CFp(TMat,a=0),quantile(Mb,.025),quantile(Mb,.975))
# Show the results
round(TMat,3)   # Show the transition matrix
round(res,3)    # Show the summary index and its confidence interval at 95%
#######################################################################################
#
#                             - Measuring Mobility -
#
# by Frank A. Cowell and E. Flachaire, October 2017
#
# replication file: Table 7, Mobility in China
#
#######################################################################################
rm(list=ls(all=TRUE))
setwd("C:/Users/Arnaud/Documents/GitHub/research_code/assetsinequalities")
# Define a function to compute the Cowell-Flachaire summary index
CFp = function(p, a=0) {
K=NROW(p)
Ma=0
if(a==0)
for(k in 1:K)
for (l in 1:K)  Ma = Ma + p[k,l]*l*log(k/l) * (-2/(K*K+K))
else if(a==1)
for(k in 1:K)
for (l in 1:K)  Ma = Ma + p[k,l]*k*log(k/l) * (2/(K*K+K))
else {
for(k in 1:K)
for (l in 1:K)  Ma = Ma + p[k,l]*k^a*l^(1-a)
Ma= (1/(a*a-a)) * ((2/(K*K+K))*Ma - 1 )
}
return(Ma)
}
# Read the data
data1 <- read.table("panelHHassets2.txt",header=TRUE)
r1=rank(data1$ass1)/NROW(data1$ass1)
r2=rank(data1$ass2)/NROW(data1$ass2)
# Compute the transition matrix
rg1 = (r1<=.2) + 2*(r1>.2 & r1<=.4) + 3*(r1>.4 & r1<=.6) + 4*(r1>.6 & r1<=.8) + 5*(r1>.8)
rg2 = (r2<=.2) + 2*(r2>.2 & r2<=.4) + 3*(r2>.4 & r2<=.6) + 4*(r2>.6 & r2<=.8) + 5*(r2>.8)
trf <- table(data.frame(R0=rg1,R1=rg2))
TMat = trf/rowSums(trf)
# Compute the bootstrap (percentile) confidence interval
nboot=999
Mb=numeric(nboot)
set.seed(100)
a1=rep(1:5, each=NROW(rg1)/5)
a2=numeric(NROW(a1))
for(b in 1:nboot) {
# generate a sample of size n from the transition matrix
for(i in 1:NROW(a1)) a2[i] = sample(5,size=1,prob=TMat[a1[i],])
# compute the transition matrix
trfb <- table(data.frame(R0=a1,R1=a2))
TMatb = trfb/rowSums(trfb)
# compute the summary index
Mb[b]=CFp(TMatb,a=0)
}
res=c(CFp(TMat,a=0),quantile(Mb,.025),quantile(Mb,.975))
# Show the results
round(TMat,3)   # Show the transition matrix
round(res,3)    # Show the summary index and its confidence interval at 95%
#######################################################################################
#
#                             - Measuring Mobility -
#
# by Frank A. Cowell and E. Flachaire, October 2017
#
# replication file: Table 8, Mobility in China
#
#######################################################################################
rm(list=ls(all=TRUE))
setwd("C:/Users/Arnaud/Documents/GitHub/research_code/assetsinequalities")
library(openxlsx)
#
A=c(-1,-0.5,0,0.5,1,1.5,2)     # set the values of the mobility index parameter (alpha in eq.(19))
nboot=999
nalpha=NROW(A)
Mboot = matrix(0,nboot,nalpha)
source("mobility.r")  # load the functions used to compute mobility indices
# Read the data
data1 <- read.table("panelHHassets1.txt",header=TRUE)
data <- data1[data1$ass1>0 & data1$ass2>0,]
attach(data)
i1=ass1
i2=ass2
Z=cbind(i1,i2)
#########################################################################
############## First, let's consider *rank* mobility indices ############
#########################################################################
# For rank mobility, we don't have asymptotic standard errors.
# Confidence intervals are computed with the bootstrap percentile method.
status=1
#################### Overall (rank) mobility
inc=Z
# compute mobility indices
M0=M.stat(inc[,1],inc[,2],a=A,status=status)$index
# compute bootstrap confidence intervals at 95% (percentile bootstrap method)
set.seed(100)
for (b in 1:nboot) {
iboot=sample(NROW(inc),replace=TRUE)
Mb <- M.stat(inc[iboot,1],inc[iboot,2],a=A,status=status)
Mboot[b,]=Mb$index
}
ICu=numeric(nalpha)
ICl=numeric(nalpha)
for (j in 1:nalpha) {
ICl[j] = quantile(Mboot[,j],probs=c(.025),type=1,names=F)
ICu[j] = quantile(Mboot[,j],probs=c(.975),type=1,names=F)
}
res1=round(cbind(A,M0,ICl,ICu),4)
#################### Downward (rank) mobility
inc=Z[(Z[,1]>Z[,2]),]
# compute mobility indices
M0=M.stat(inc[,1],inc[,2],a=A,status=status)$index
# compute bootstrap confidence intervals at 95% (percentile bootstrap method)
set.seed(100)
for (b in 1:nboot) {
iboot=sample(NROW(inc),replace=TRUE)
Mb <- M.stat(inc[iboot,1],inc[iboot,2],a=A,status=status)
Mboot[b,]=Mb$index
}
ICu=numeric(nalpha)
ICl=numeric(nalpha)
for (j in 1:nalpha) {
ICl[j] = quantile(Mboot[,j],probs=c(.025),type=1,names=F)
ICu[j] = quantile(Mboot[,j],probs=c(.975),type=1,names=F)
}
res2=round(cbind(A,M0,ICl,ICu),4)
#################### Upward (rank) mobility
inc=Z[(Z[,1]<=Z[,2]),]
# compute mobility indices
M0=M.stat(inc[,1],inc[,2],a=A,status=status)$index
# compute bootstrap confidence intervals at 95% (percentile bootstrap method)
set.seed(100)
for (b in 1:nboot) {
iboot=sample(NROW(inc),replace=TRUE)
Mb <- M.stat(inc[iboot,1],inc[iboot,2],a=A,status=status)
Mboot[b,]=Mb$index
}
ICu=numeric(nalpha)
ICl=numeric(nalpha)
for (j in 1:nalpha) {
ICl[j] = quantile(Mboot[,j],probs=c(.025),type=1,names=F)
ICu[j] = quantile(Mboot[,j],probs=c(.975),type=1,names=F)
}
res3=round(cbind(A,M0,ICl,ICu),4)
################## Save the results
res=rbind(res1[1,],res2[1,],res3[1,],res1[2,],res2[2,],res3[2,],res1[3,],res2[3,],res3[3,],res1[4,],res2[4,],res3[4,],res1[5,],res2[5,],res3[5,],res1[6,],res2[6,],res3[6,],res1[7,],res2[7,],res3[7,])
rownames(res)=c("overall","downward","upward","overall","downward","upward","overall","downward","upward","overall","downward","upward","overall","downward","upward","overall","downward","upward","overall","downward","upward")
colnames(res)=c("alpha","index","CI_lower", "CI_upper")
res_rank=res
#########################################################################
############ Second, let's consider *income* mobility indices ###########
#########################################################################
# For income mobility, we have asymptotic standard errors.
# Confidence intervals are computed with the bootstrap studentized method.
status=0
#################### Overall (income) mobility
inc=Z
# compute mobility indices and standard errors
M0=M.stat(inc[,1],inc[,2],a=A,status=status)$index
M0se=M.stat(inc[,1],inc[,2],a=A,status=status)$se
# compute asymptotic confidence intervals
ICuas=M0+1.96*M0se
IClas=M0-1.96*M0se
# compute bootstrap confidence intervals (bootstrap-t method)
set.seed(100)
for (b in 1:nboot) {
iboot=sample(NROW(inc),replace=T)     # as.integer(runif(nobs)*nobs+1)
Mb <- M.stat(inc[iboot,1],inc[iboot,2],a=A,status=status)
Mboot[b,]=(Mb$index-M0)/Mb$se
}
ICu=numeric(nalpha)
ICl=numeric(nalpha)
for (j in 1:nalpha) {
ICu[j] = M0[j]-quantile(Mboot[,j],probs=c(.025),type=1,names=F)*M0se[j]
ICl[j] = M0[j]-quantile(Mboot[,j],probs=c(.975),type=1,names=F)*M0se[j]
}
res1=round(cbind(A,M0,ICl,ICu,IClas,ICuas),4)
#################### Downward (income) mobility
inc=Z[(Z[,1]>Z[,2]),]
# compute mobility indices and standard errors
M0=M.stat(inc[,1],inc[,2],a=A,status=status)$index
M0se=M.stat(inc[,1],inc[,2],a=A,status=status)$se
# compute asymptotic confidence intervals
ICuas=M0+1.96*M0se
IClas=M0-1.96*M0se
# compute bootstrap confidence intervals (bootstrap-t method)
set.seed(100)
for (b in 1:nboot) {
iboot=sample(NROW(inc),replace=T)     # as.integer(runif(nobs)*nobs+1)
Mb <- M.stat(inc[iboot,1],inc[iboot,2],a=A,status=status)
Mboot[b,]=(Mb$index-M0)/Mb$se
}
ICu=numeric(nalpha)
ICl=numeric(nalpha)
for (j in 1:nalpha) {
ICu[j] = M0[j]-quantile(Mboot[,j],probs=c(.025),type=1,names=F)*M0se[j]
ICl[j] = M0[j]-quantile(Mboot[,j],probs=c(.975),type=1,names=F)*M0se[j]
}
res2=round(cbind(A,M0,ICl,ICu,IClas,ICuas),4)
#################### Upward (income) mobility
inc=Z[(Z[,1]<=Z[,2]),]
# compute mobility indices and standard errors
M0=M.stat(inc[,1],inc[,2],a=A,status=status)$index
M0se=M.stat(inc[,1],inc[,2],a=A,status=status)$se
# compute asymptotic confidence intervals
ICuas=M0+1.96*M0se
IClas=M0-1.96*M0se
# compute bootstrap confidence intervals (bootstrap-t method)
set.seed(100)
for (b in 1:nboot) {
iboot=sample(NROW(inc),replace=T)     # as.integer(runif(nobs)*nobs+1)
Mb <- M.stat(inc[iboot,1],inc[iboot,2],a=A,status=status)
Mboot[b,]=(Mb$index-M0)/Mb$se
}
ICu=numeric(nalpha)
ICl=numeric(nalpha)
for (j in 1:nalpha) {
ICu[j] = M0[j]-quantile(Mboot[,j],probs=c(.025),type=1,names=F)*M0se[j]
ICl[j] = M0[j]-quantile(Mboot[,j],probs=c(.975),type=1,names=F)*M0se[j]
}
res3=round(cbind(A,M0,ICl,ICu,IClas,ICuas),4)
################## Save the results
res=rbind(res1[1,],res2[1,],res3[1,],res1[2,],res2[2,],res3[2,],res1[3,],res2[3,],res3[3,],res1[4,],res2[4,],res3[4,],res1[5,],res2[5,],res3[5,],res1[6,],res2[6,],res3[6,],res1[7,],res2[7,],res3[7,])
rownames(res)=c("overall","downward","upward","overall","downward","upward","overall","downward","upward","overall","downward","upward","overall","downward","upward","overall","downward","upward","overall","downward","upward")
colnames(res)=c("alpha","index","CI_lower", "CI_upper","CI_lower_asymp", "CI_upper_asymp")
res_inc=res[,1:4]
#########################################################################
#############################  Results ##################################
#########################################################################
res_rank
write.xlsx(res_rank, 'CF_detrank.xlsx')
res_inc
write.xlsx(res_inc, 'CF_detass.xlsx')
#######################################################################################
#
#                             - Measuring Mobility -
#
# by Frank A. Cowell and E. Flachaire, October 2017
#
# replication file: Table 8, Mobility in China
#
#######################################################################################
rm(list=ls(all=TRUE))
setwd("C:/Users/Arnaud/Documents/GitHub/research_code/assetsinequalities")
library(openxlsx)
#
A=c(-1,-0.5,0,0.5,1,1.5,2)     # set the values of the mobility index parameter (alpha in eq.(19))
nboot=999
nalpha=NROW(A)
Mboot = matrix(0,nboot,nalpha)
source("mobility.r")  # load the functions used to compute mobility indices
# Read the data
data1 <- read.table("panelHHassets2.txt",header=TRUE)
data <- data1[data1$ass1>0 & data1$ass2>0,]
attach(data)
i1=ass1
i2=ass2
Z=cbind(i1,i2)
#########################################################################
############## First, let's consider *rank* mobility indices ############
#########################################################################
# For rank mobility, we don't have asymptotic standard errors.
# Confidence intervals are computed with the bootstrap percentile method.
status=1
#################### Overall (rank) mobility
inc=Z
# compute mobility indices
M0=M.stat(inc[,1],inc[,2],a=A,status=status)$index
# compute bootstrap confidence intervals at 95% (percentile bootstrap method)
set.seed(100)
for (b in 1:nboot) {
iboot=sample(NROW(inc),replace=TRUE)
Mb <- M.stat(inc[iboot,1],inc[iboot,2],a=A,status=status)
Mboot[b,]=Mb$index
}
ICu=numeric(nalpha)
ICl=numeric(nalpha)
for (j in 1:nalpha) {
ICl[j] = quantile(Mboot[,j],probs=c(.025),type=1,names=F)
ICu[j] = quantile(Mboot[,j],probs=c(.975),type=1,names=F)
}
res1=round(cbind(A,M0,ICl,ICu),4)
#################### Downward (rank) mobility
inc=Z[(Z[,1]>Z[,2]),]
# compute mobility indices
M0=M.stat(inc[,1],inc[,2],a=A,status=status)$index
# compute bootstrap confidence intervals at 95% (percentile bootstrap method)
set.seed(100)
for (b in 1:nboot) {
iboot=sample(NROW(inc),replace=TRUE)
Mb <- M.stat(inc[iboot,1],inc[iboot,2],a=A,status=status)
Mboot[b,]=Mb$index
}
ICu=numeric(nalpha)
ICl=numeric(nalpha)
for (j in 1:nalpha) {
ICl[j] = quantile(Mboot[,j],probs=c(.025),type=1,names=F)
ICu[j] = quantile(Mboot[,j],probs=c(.975),type=1,names=F)
}
res2=round(cbind(A,M0,ICl,ICu),4)
#################### Upward (rank) mobility
inc=Z[(Z[,1]<=Z[,2]),]
# compute mobility indices
M0=M.stat(inc[,1],inc[,2],a=A,status=status)$index
# compute bootstrap confidence intervals at 95% (percentile bootstrap method)
set.seed(100)
for (b in 1:nboot) {
iboot=sample(NROW(inc),replace=TRUE)
Mb <- M.stat(inc[iboot,1],inc[iboot,2],a=A,status=status)
Mboot[b,]=Mb$index
}
ICu=numeric(nalpha)
ICl=numeric(nalpha)
for (j in 1:nalpha) {
ICl[j] = quantile(Mboot[,j],probs=c(.025),type=1,names=F)
ICu[j] = quantile(Mboot[,j],probs=c(.975),type=1,names=F)
}
res3=round(cbind(A,M0,ICl,ICu),4)
################## Save the results
res=rbind(res1[1,],res2[1,],res3[1,],res1[2,],res2[2,],res3[2,],res1[3,],res2[3,],res3[3,],res1[4,],res2[4,],res3[4,],res1[5,],res2[5,],res3[5,],res1[6,],res2[6,],res3[6,],res1[7,],res2[7,],res3[7,])
rownames(res)=c("overall","downward","upward","overall","downward","upward","overall","downward","upward","overall","downward","upward","overall","downward","upward","overall","downward","upward","overall","downward","upward")
colnames(res)=c("alpha","index","CI_lower", "CI_upper")
res_rank=res
#########################################################################
############ Second, let's consider *income* mobility indices ###########
#########################################################################
# For income mobility, we have asymptotic standard errors.
# Confidence intervals are computed with the bootstrap studentized method.
status=0
#################### Overall (income) mobility
inc=Z
# compute mobility indices and standard errors
M0=M.stat(inc[,1],inc[,2],a=A,status=status)$index
M0se=M.stat(inc[,1],inc[,2],a=A,status=status)$se
# compute asymptotic confidence intervals
ICuas=M0+1.96*M0se
IClas=M0-1.96*M0se
# compute bootstrap confidence intervals (bootstrap-t method)
set.seed(100)
for (b in 1:nboot) {
iboot=sample(NROW(inc),replace=T)     # as.integer(runif(nobs)*nobs+1)
Mb <- M.stat(inc[iboot,1],inc[iboot,2],a=A,status=status)
Mboot[b,]=(Mb$index-M0)/Mb$se
}
ICu=numeric(nalpha)
ICl=numeric(nalpha)
for (j in 1:nalpha) {
ICu[j] = M0[j]-quantile(Mboot[,j],probs=c(.025),type=1,names=F)*M0se[j]
ICl[j] = M0[j]-quantile(Mboot[,j],probs=c(.975),type=1,names=F)*M0se[j]
}
res1=round(cbind(A,M0,ICl,ICu,IClas,ICuas),4)
#################### Downward (income) mobility
inc=Z[(Z[,1]>Z[,2]),]
# compute mobility indices and standard errors
M0=M.stat(inc[,1],inc[,2],a=A,status=status)$index
M0se=M.stat(inc[,1],inc[,2],a=A,status=status)$se
# compute asymptotic confidence intervals
ICuas=M0+1.96*M0se
IClas=M0-1.96*M0se
# compute bootstrap confidence intervals (bootstrap-t method)
set.seed(100)
for (b in 1:nboot) {
iboot=sample(NROW(inc),replace=T)     # as.integer(runif(nobs)*nobs+1)
Mb <- M.stat(inc[iboot,1],inc[iboot,2],a=A,status=status)
Mboot[b,]=(Mb$index-M0)/Mb$se
}
ICu=numeric(nalpha)
ICl=numeric(nalpha)
for (j in 1:nalpha) {
ICu[j] = M0[j]-quantile(Mboot[,j],probs=c(.025),type=1,names=F)*M0se[j]
ICl[j] = M0[j]-quantile(Mboot[,j],probs=c(.975),type=1,names=F)*M0se[j]
}
res2=round(cbind(A,M0,ICl,ICu,IClas,ICuas),4)
#################### Upward (income) mobility
inc=Z[(Z[,1]<=Z[,2]),]
# compute mobility indices and standard errors
M0=M.stat(inc[,1],inc[,2],a=A,status=status)$index
M0se=M.stat(inc[,1],inc[,2],a=A,status=status)$se
# compute asymptotic confidence intervals
ICuas=M0+1.96*M0se
IClas=M0-1.96*M0se
# compute bootstrap confidence intervals (bootstrap-t method)
set.seed(100)
for (b in 1:nboot) {
iboot=sample(NROW(inc),replace=T)     # as.integer(runif(nobs)*nobs+1)
Mb <- M.stat(inc[iboot,1],inc[iboot,2],a=A,status=status)
Mboot[b,]=(Mb$index-M0)/Mb$se
}
ICu=numeric(nalpha)
ICl=numeric(nalpha)
for (j in 1:nalpha) {
ICu[j] = M0[j]-quantile(Mboot[,j],probs=c(.025),type=1,names=F)*M0se[j]
ICl[j] = M0[j]-quantile(Mboot[,j],probs=c(.975),type=1,names=F)*M0se[j]
}
res3=round(cbind(A,M0,ICl,ICu,IClas,ICuas),4)
################## Save the results
res=rbind(res1[1,],res2[1,],res3[1,],res1[2,],res2[2,],res3[2,],res1[3,],res2[3,],res3[3,],res1[4,],res2[4,],res3[4,],res1[5,],res2[5,],res3[5,],res1[6,],res2[6,],res3[6,],res1[7,],res2[7,],res3[7,])
rownames(res)=c("overall","downward","upward","overall","downward","upward","overall","downward","upward","overall","downward","upward","overall","downward","upward","overall","downward","upward","overall","downward","upward")
colnames(res)=c("alpha","index","CI_lower", "CI_upper","CI_lower_asymp", "CI_upper_asymp")
res_inc=res[,1:4]
#########################################################################
#############################  Results ##################################
#########################################################################
res_rank
write.xlsx(res_rank, 'CF_detrank.xlsx')
res_inc
write.xlsx(res_inc, 'CF_detass.xlsx')
